/* SPDX-License-Identifier: GPL-2.0 */
/* Generated by Documentation/scheduler/sched-pelt; do not modify. */

/*
 * IAMROOT, 2022.12.31:
 * - ___update_load_sum()함수 주석 참고
 *   y^32 = 0.5
 *   y = 10^(log0.5 / 32)
 *     = 0.97857206208
 * - 1ms단위로 y^n에 대한 값이 [n]으로 들어가 있다.
 *   [32]에는 0.5가 들어 있는 개념(0x8000_0000)이 된다.(32은 필요없어서 없다)
 */
static const u32 runnable_avg_yN_inv[] __maybe_unused = {
	0xffffffff, 0xfa83b2da, 0xf5257d14, 0xefe4b99a, 0xeac0c6e6, 0xe5b906e6,
	0xe0ccdeeb, 0xdbfbb796, 0xd744fcc9, 0xd2a81d91, 0xce248c14, 0xc9b9bd85,
	0xc5672a10, 0xc12c4cc9, 0xbd08a39e, 0xb8fbaf46, 0xb504f333, 0xb123f581,
	0xad583ee9, 0xa9a15ab4, 0xa5fed6a9, 0xa2704302, 0x9ef5325f, 0x9b8d39b9,
	0x9837f050, 0x94f4efa8, 0x91c3d373, 0x8ea4398a, 0x8b95c1e3, 0x88980e80,
	0x85aac367, 0x82cd8698,
};

#define LOAD_AVG_PERIOD 32

/*
 * IAMROOT, 2022.12.31:
 * --- 유도 ---
 * - load_avg = u_0` + y*(u_0 + u_1*y + u_2*y^2 + ... )
 *            = u_0 + u_1*y + u_2*y^2 + ... [re-labeling u_i --> u_{i+1}]
 *   y^32 = 0.5
 *
 * - 0.97857206208^n, n은 1부터 무한의 sum값
 *   sum = a/(1-r) + a^0
 *       = 0.97857206208 / (1 - 0.97857206208) + 1
 *       = 46.6680463483 
 *
 *   이걸 이진화정수화.
 *   46.6680463483 * 1024 = 47788.0794607
 *
 * - 값이 조금 크다.
 *   옛날에  LOAD_AVG_MAX_N 345 이라는 제한을 뒀던걸 찾아냈다. 무한대가 아닌
 *   345까지 재계산해본다.
 *
 *   (0.97857206208 * (1 - 0.97857206208^345) / (1 - 0.97857206208) + 1) * 1024)
 *   = 47761.5069404 
 *
 * - 그래도 값이 조금 크다.
 *   345가 아닌 320까지 하면 꽤 근사치가 나오긴한다.
 *
 *   (0.97857206208 * (1 - 0.97857206208^320) / (1 - 0.97857206208) + 1) * 1024 
 *   = 47742.4114145 
 *
 * - 오차의 이유
 *   kernel은 calc_converged_max()함수를 통해 계산된 값을 LOAD_AVG_PERIOD, 
 *   LOAD_AVG_MAX값을 사용한다.
 *   수식적으로 계산하면 저 값과 비슷하지만 calc_converged_max()처럼 계산하면
 *   저런 오차가 발생하는듯 하다.
 * ------------
 *
 * - y^32 = 0.5의 값인 y = 10^(log(0.5) / 32)의 값에서
 *   y^n 일때 n = 0부터 무한대까지 합한 값.
 */
#define LOAD_AVG_MAX 47742
